<script>
  const canvas = document.getElementById("scratch");
  const ctx = canvas.getContext("2d", { willReadFrequently: false });
  const card = document.getElementById("card");
  const hint = document.getElementById("hint");
  const resetBtn = document.getElementById("resetBtn");
  const fullBtn = document.getElementById("fullBtn");

  const WRAP_SRC = "wrap.png"; // papier cadeau mystique
  const BRUSH_RADIUS = 26;     // taille du "grattage" (px en CSS pixels)
  const FADE_HINT_AFTER = 35;  // après X coups de grattage, on cache l'indication

  let wrapImg = new Image();
  wrapImg.src = WRAP_SRC;

  let scratching = false;
  let strokes = 0;

  // DPR unique utilisé partout (évite les décalages)
  let DPR = 1;

  function fitCanvasToCard() {
    const rect = card.getBoundingClientRect();

    // Clamp pour éviter des canvas énormes, mais on DOIT réutiliser ce DPR partout
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);

    // On dessine en "CSS pixels"
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    drawWrap();
  }

  function getCanvasSizeCssPixels() {
    return {
      w: canvas.width / DPR,
      h: canvas.height / DPR
    };
  }

  function drawWrap() {
    const { w, h } = getCanvasSizeCssPixels();

    ctx.globalCompositeOperation = "source-over";
    ctx.clearRect(0, 0, w, h);

    if (!wrapImg.complete) return;

    const iw = wrapImg.naturalWidth;
    const ih = wrapImg.naturalHeight;

    // "cover" pour remplir tout le carré
    const scale = Math.max(w / iw, h / ih);
    const dw = iw * scale;
    const dh = ih * scale;
    const dx = (w - dw) / 2;
    const dy = (h - dh) / 2;

    ctx.drawImage(wrapImg, dx, dy, dw, dh);

    // voile mystique léger
    const g = ctx.createRadialGradient(w*0.5, h*0.35, 20, w*0.5, h*0.5, Math.max(w,h)*0.7);
    g.addColorStop(0, "rgba(255,255,255,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0.00)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);

    strokes = 0;
    hint.style.opacity = 1;
  }

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;

    if (e.touches && e.touches[0]) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function scratchAt(x, y) {
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.arc(x, y, BRUSH_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    strokes++;
    if (strokes > FADE_HINT_AFTER) hint.style.opacity = 0;
  }

  function start(e) {
    e.preventDefault();
    scratching = true;
    const {x,y} = getPos(e);
    scratchAt(x,y);
  }

  function move(e) {
    if (!scratching) return;
    e.preventDefault();
    const {x,y} = getPos(e);
    scratchAt(x,y);
  }

  function end() {
    scratching = false;
  }

  // Touch (mobile)
  canvas.addEventListener("touchstart", start, { passive: false });
  canvas.addEventListener("touchmove", move, { passive: false });
  canvas.addEventListener("touchend", end, { passive: false });

  // Mouse (PC)
  canvas.addEventListener("mousedown", start);
  window.addEventListener("mousemove", move);
  window.addEventListener("mouseup", end);

  resetBtn.addEventListener("click", () => drawWrap());

  fullBtn.addEventListener("click", () => {
    const { w, h } = getCanvasSizeCssPixels();
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillRect(0, 0, w, h);
    hint.style.opacity = 0;
  });

  wrapImg.onload = () => fitCanvasToCard();
  window.addEventListener("resize", fitCanvasToCard);
  window.addEventListener("orientationchange", fitCanvasToCard);

  if (wrapImg.complete) fitCanvasToCard();
</script>

